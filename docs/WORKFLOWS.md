# Workflows: How ADR Kit Automates Architectural Decision Management

**ADR Kit workflows are hybrid automation engines** that combine deterministic file operations with LLM-powered coordination to manage your architectural decisions. This document explains how they work, when to use them, and what happens behind the scenes.

---

## Table of Contents

1. [The Workflow Architecture Pattern](#the-workflow-architecture-pattern)
2. [Complete User Scenarios](#complete-user-scenarios)
3. [Individual Workflow Deep Dives](#individual-workflow-deep-dives)
4. [Quick Reference](#quick-reference)

---

# The Workflow Architecture Pattern

Before diving into individual workflows, it's essential to understand the overall design philosophy and pattern that all 6 workflows follow.

## What Are Workflows? The Big Picture

### The Pattern

```
You (User) ↔ AI Agent ↔ MCP Tools ↔ Workflows ↔ {Automation + LLM Coordination}
```

Workflows sit at the heart of ADR Kit. They're called by AI agents through MCP (Model Context Protocol) tools, and they orchestrate everything from file operations to policy enforcement.

### Key Concepts

#### 1. Workflows are Hybrid Systems

Every workflow has **two distinct parts**:

**AUTOMATION** (Deterministic):
- File scanning and technology detection
- File writing (ADRs, config files, indexes)
- Policy checking and conflict detection
- Config generation (ESLint, Ruff, etc.)
- ✅ Same output every time for same input

**LLM COORDINATION** (Generative):
- Analysis promptlets: "Examine this codebase for decisions..."
- Guidance promptlets: "Pay attention to ADR-0005..."
- Validation promptlets: "✓ Check Auth0 is used..."
- ✅ Agent's LLM uses these to generate context-aware responses

#### 2. Workflows Don't Have Reasoning Capabilities

Workflows are **not AI** - they're deterministic programs that:
- ❌ Can't "understand" your code semantically
- ❌ Can't make subjective architectural judgments
- ❌ Can't analyze code quality or design patterns
- ✅ CAN: detect technology patterns, check policies, write files, generate instructions

#### 3. The AI Agent's LLM Provides Reasoning

The **AI agent** (Claude, GPT-4, etc.) provides the reasoning layer:
- Reads promptlets generated by workflows
- Examines your code following workflow instructions
- Makes reasoned architectural suggestions
- Decides when to call more workflows (creates loop-backs)

### Why This Design?

**Separation of Concerns**:
```
┌─────────────────────────────────────────────────────────┐
│ Workflows                                               │
│ • File operations (fast, reliable)                      │
│ • Pattern matching (deterministic)                      │
│ • Config generation (consistent)                        │
└─────────────────────────────────────────────────────────┘
                         ↓
                 Generates promptlets
                         ↓
┌─────────────────────────────────────────────────────────┐
│ AI Agent's LLM                                          │
│ • Semantic code analysis (flexible)                     │
│ • Architectural reasoning (context-aware)               │
│ • User interaction (natural language)                   │
└─────────────────────────────────────────────────────────┘
```

**Benefits**:
- **Speed**: Automation handles mechanical tasks in milliseconds
- **Reliability**: Deterministic operations produce consistent results
- **Flexibility**: LLM reasoning adapts to your specific project context
- **Safety**: Human oversight at critical decision points (approvals)

## The Two-Part Workflow Pattern

Every workflow returns **TWO types of outputs** to the AI agent:

### Part A: Automation Results (Data/Files)

This is the **deterministic output** - what the workflow actually DID:

```json
{
  "detected_technologies": ["React", "Express", "PostgreSQL"],
  "file_written": "docs/adr/ADR-0001-use-react.md",
  "policies_activated": ["no-restricted-imports: axios"],
  "configurations_updated": [".eslintrc.adrs.json", "adr-index.json"]
}
```

### Part B: LLM Coordination (Promptlets)

This is the **guidance output** - what the workflow wants the AGENT'S LLM to DO:

```json
{
  "analysis_prompt": "Examine this codebase for authentication patterns. Check for Auth0, Passport, or custom implementations. For each pattern found, note: 1) Where it's used, 2) Configuration approach, 3) Security considerations...",
  "guidance": "✅ You can proceed with React Query for data fetching",
  "next_steps": [
    "Use adr_create() to document this decision",
    "Review the created ADR before approval"
  ]
}
```

### Example: The Two Parts in Action

**Workflow**: `adr_analyze_project`

**Automation Result** (what it found):
```json
{
  "detected_technologies": ["React", "Express", "Auth0"],
  "confidence_scores": {"React": 0.9, "Express": 0.8, "Auth0": 0.7},
  "existing_adr_count": 0
}
```

**LLM Coordination** (what it wants the agent to do):
```json
{
  "analysis_prompt": "Please analyze this project for architectural decisions...\n\n**Project Context:**\n- Technologies detected: React (90% confidence), Express (80% confidence), Auth0 (70% confidence)\n- No existing ADRs found\n\n**Your Task:**\n1. Examine src/components/ for React patterns\n2. Check src/server.ts for Express API design\n3. Review src/auth/ for Auth0 integration\n4. For each architectural decision you identify:\n   - Document the context (why was this needed?)\n   - Note the decision (what was chosen?)\n   - List consequences (trade-offs made)\n...",
  "next_steps": [
    "Follow the analysis prompt to examine the codebase",
    "Identify all significant architectural decisions",
    "Present findings to user before creating ADRs"
  ]
}
```

The agent's LLM then:
1. Reads the `analysis_prompt` (the detailed instructions)
2. Examines the actual codebase files
3. Uses its reasoning capabilities to identify decisions
4. Presents findings to you (the user)
5. Waits for your permission before creating ADRs

## Understanding Loop-Backs

**Loop-backs** are when an AI agent calls multiple workflows in sequence based on the promptlets received.

### Linear Flow (No Loop)

Some workflows are **terminal** - they don't trigger additional workflows:

```
You: "Approve ADR-0001"
  ↓
Agent calls: adr_approve('ADR-0001')
  ↓
Workflow runs (9-step automation pipeline)
  ↓
Agent receives: "✅ Policies activated"
  ↓
Agent tells you: "ADR-0001 is now active"
  ↓
DONE (no further workflows needed)
```

### Loop-Back Flow (Typical)

Most workflows **trigger additional workflows** through their promptlets:

```
You: "Analyze my project"
  ↓
Agent calls: adr_analyze_project()
  ↓
Workflow returns: {analysis_prompt: "Examine codebase for decisions..."}
  ↓
Agent's LLM reads promptlet
  ↓
Agent's LLM examines code
  ↓
Agent's LLM identifies 4 decisions
  ↓
Agent shows you: "Found 4 decisions. Create ADRs?"
  ↓
You: "Yes"  ← USER PERMISSION REQUIRED
  ↓
Agent calls: adr_create() [LOOP BACK #1]
Agent calls: adr_create() [LOOP BACK #2]
Agent calls: adr_create() [LOOP BACK #3]
Agent calls: adr_create() [LOOP BACK #4]
  ↓
Agent shows you: "Created 4 ADRs. Approve them?"
  ↓
You: "Approve all"  ← USER APPROVAL REQUIRED
  ↓
Agent calls: adr_approve('ADR-0001') [LOOP BACK #5]
Agent calls: adr_approve('ADR-0002') [LOOP BACK #6]
Agent calls: adr_approve('ADR-0003') [LOOP BACK #7]
Agent calls: adr_approve('ADR-0004') [LOOP BACK #8]
  ↓
DONE
```

**Total**: 9 MCP tool calls triggered by one initial request!

### Why Loop-Backs Happen

Loop-backs occur because:
1. **Workflows return instructions** (not just final results)
2. **Agent's LLM reads and acts** on those instructions
3. **Actions often require calling more workflows** (create → approve, etc.)
4. **User approval gates** ensure human oversight at key points

This creates a **dynamic, context-aware flow** that adapts to your specific project needs.

## User Approval Points

**Critical safety feature**: Not all workflow calls are automatic. Some require explicit user confirmation:

| Action | User Approval Required? | Why |
|--------|-------------------------|-----|
| Analyze project | ❌ No | Just scanning files (read-only) |
| Preflight check | ❌ No | Just checking policies (read-only) |
| Get planning context | ❌ No | Just providing reference (read-only) |
| **Create ADR** | ⚠️ **Recommended** | Writes a file (usually safe, but agent should ask in bulk scenarios) |
| **Approve ADR** | ✅ **ALWAYS YES** | Activates policy enforcement - requires human oversight |
| **Supersede ADR** | ✅ **YES** | Changes architectural decisions - requires human oversight |

### Why Approval Requires User Confirmation

**Approving an ADR**:
- Updates ADR status to "accepted"
- Activates policy enforcement (ESLint, Ruff rules)
- Writes 3-5 configuration files
- Makes policies **enforceable** in your editor and CI/CD

**This is a significant change** that should never happen automatically. The agent will ALWAYS wait for your explicit "approve" confirmation.

## The 6 Workflows Overview

ADR Kit has exactly **6 workflows**, each serving a specific purpose:

| Workflow | When Used | Primary Function | Automation Level | LLM Coordination | Typical Loop-Backs |
|----------|-----------|------------------|------------------|------------------|-------------------|
| **Analyze Project** | Brownfield onboarding | Detect technologies & generate analysis plan | Medium | **Heavy** (analysis promptlet) | → Create (multiple) |
| **Preflight Check** | Before technical choice | Check if choice is allowed/blocked | Light | Medium (guidance) | Conditional → Create |
| **Create ADR** | Document decision | Write ADR file, check conflicts | Heavy | Medium (next steps) | → Approve |
| **Approve ADR** | Activate policies | **9-step automation pipeline** | **Very Heavy** | Light (status message) | None (terminal) |
| **Supersede ADR** | Change decision | Update ADRs, manage relationships | Heavy | Light (status) | Conditional → Approve |
| **Planning Context** | Before implementation | Find relevant ADRs & generate guidance | Light | **Heavy** (guidance promptlets) | None (reference) |

### Automation vs LLM Coordination Levels

**Heavy Automation**:
- Workflow does most of the work itself
- File operations, config generation, policy checking
- Agent just calls the workflow and reports results

**Heavy LLM Coordination**:
- Workflow provides detailed instructions (promptlets)
- Agent's LLM does the actual reasoning/analysis
- Agent decides what to do next based on findings

### The 4 Common Workflow Patterns

#### Pattern 1: The Standard Flow (Preflight → Create → Approve)
```
User wants to use technology X
→ Agent checks if allowed (preflight)
→ Agent creates ADR (create)
→ User reviews
→ User approves (approve)
→ Policies active
```

#### Pattern 2: The Analysis Flow (Analyze → Create × N → Approve × N)
```
User has existing project
→ Agent analyzes project (analyze)
→ Agent's LLM examines code
→ Agent creates multiple ADRs (create × N)
→ User reviews all
→ User approves all (approve × N)
→ Policies active
```

#### Pattern 3: The Change Flow (Supersede → Approve)
```
User wants to change decision
→ Agent supersedes old ADR (supersede)
→ User reviews new ADR
→ User approves new ADR (approve)
→ New policies active, old superseded
```

#### Pattern 4: The Guidance Flow (Planning → Implementation)
```
User starts implementing feature
→ Agent gets architectural context (planning)
→ Agent uses guidance during implementation
→ No loop-back (just reference)
```

---

## Summary: The Workflow Architecture

**What You Need to Remember**:

1. **Hybrid Design**: Every workflow has automation (deterministic) + LLM coordination (promptlets)

2. **Two Outputs**: Data/files (what was done) + Promptlets (what agent should do next)

3. **Loop-Backs Are Normal**: One request often triggers multiple workflow calls

4. **User Approval Required**: Approvals and major changes always need your explicit confirmation

5. **Reasoning Comes from LLM**: Workflows provide instructions, agent's LLM provides reasoning

6. **6 Workflows, 4 Patterns**: Analyze, Preflight, Create, Approve, Supersede, Planning

With this foundation, you're ready to understand each workflow in detail. The next section shows complete user scenarios from start to finish.

---

# Complete User Scenarios

This section shows **real-world examples** of how workflows are used from start to finish. Each scenario shows:
- What you (the user) say
- How the agent responds
- Which workflows are triggered
- When user approval is required
- What files are created/updated

## Scenario 1: Greenfield Project - First ADR

**User Goal**: Document the decision to use React for UI in a new project

### Complete Interaction

```
═══════════════════════════════════════════════════════════════
USER (Start)
═══════════════════════════════════════════════════════════════

You: "I'm using React for my new project. Help me create an ADR for this decision."

═══════════════════════════════════════════════════════════════
AGENT (Reasons & Acts)
═══════════════════════════════════════════════════════════════

Agent reasons: "User wants to document a technical decision"
Agent reasons: "Should I check if this requires an ADR first? Yes - preflight check"

───────────────────────────────────────────────────────────────
STEP 1: Preflight Check
───────────────────────────────────────────────────────────────

Agent calls: adr_preflight({
  choice: "React",
  context: "Frontend framework for new project",
  category: "frontend"
})

Workflow executes:
├─ Load constraints contract (no ADRs yet in greenfield)
├─ Categorize: React → "frontend framework"
├─ Check significance: framework choice = significant
├─ Decision: REQUIRES_ADR
└─ Generate guidance promptlet

Returns:
{
  "decision": "REQUIRES_ADR",
  "reasoning": "Framework choice is architecturally significant",
  "guidance": "📝 'React' requires ADR. Document this decision before proceeding.",
  "next_steps": ["Create ADR proposal documenting this decision"]
}

Agent's LLM reads promptlet: "needs ADR"
Agent reasons: "I'll help create the ADR"

───────────────────────────────────────────────────────────────
STEP 2: Create ADR [LOOP BACK]
───────────────────────────────────────────────────────────────

Agent calls: adr_create({
  title: "Use React for Frontend UI",
  context: "New web application needs modern, component-based UI framework with strong ecosystem and TypeScript support",
  decision: "Use React for all frontend components and UI development",
  consequences: "Positive:\n- Component reusability and composability\n- Large ecosystem with extensive third-party libraries\n- Strong TypeScript support\n- Virtual DOM performance\n\nNegative:\n- Learning curve for team members new to React\n- Requires build tooling (Webpack/Vite)\n- JSX syntax may be unfamiliar",
  tags: ["frontend", "framework", "ui"]
})

Workflow executes:
├─ Generate ID: ADR-0001 (first ADR!)
├─ Validate input: ✓ All fields valid
├─ Find related ADRs: None (first ADR in project)
├─ Detect conflicts: None
├─ Build ADR structure
├─ Write file: docs/adr/ADR-0001-use-react-for-frontend.md
│   status: "proposed" (NOT approved yet!)
└─ Generate next steps promptlet

Returns:
{
  "adr_id": "ADR-0001",
  "file_path": "docs/adr/ADR-0001-use-react-for-frontend.md",
  "status": "proposed",
  "conflicts": [],
  "related_adrs": [],
  "review_required": true,
  "guidance": "📋 ADR-0001 requires review due to architectural significance. Have a human review the proposal, then use adr_approve() to activate it.",
  "next_steps": [
    "Review the created ADR",
    "Use adr_approve('ADR-0001') to activate this decision"
  ]
}

Agent's LLM reads promptlet: "needs review before approval"

═══════════════════════════════════════════════════════════════
AGENT → USER (Shows ADR, WAITS for approval)
═══════════════════════════════════════════════════════════════

Agent: "I've created ADR-0001 for your React decision. Here's the content:

───────────────────────────────────────────────────────────────
**ADR-0001: Use React for Frontend UI**

**Status**: Proposed
**Date**: 2025-10-02
**Tags**: frontend, framework, ui

## Context

New web application needs modern, component-based UI framework with strong ecosystem and TypeScript support.

## Decision

Use React for all frontend components and UI development.

## Consequences

Positive:
- Component reusability and composability
- Large ecosystem with extensive third-party libraries
- Strong TypeScript support
- Virtual DOM performance

Negative:
- Learning curve for team members new to React
- Requires build tooling (Webpack/Vite)
- JSX syntax may be unfamiliar
───────────────────────────────────────────────────────────────

Does this look good? Should I approve it to activate any policies?"

[AGENT WAITS - DOES NOT AUTO-APPROVE]

═══════════════════════════════════════════════════════════════
USER (Reviews & EXPLICITLY Approves)
═══════════════════════════════════════════════════════════════

You: "Yes, approve it"  ← REQUIRED USER CONFIRMATION

═══════════════════════════════════════════════════════════════
AGENT (Acts ONLY after user approval)
═══════════════════════════════════════════════════════════════

───────────────────────────────────────────────────────────────
STEP 3: Approve ADR [LOOP BACK - User Initiated]
───────────────────────────────────────────────────────────────

Agent calls: adr_approve({adr_id: "ADR-0001"})

Workflow executes (9-step automation pipeline):
1. Load ADR-0001 ✓
2. SHA-256 integrity check ✓
3. Update status: proposed → accepted (write file) ✓
4. Rebuild constraints contract → .adr-kit/constraints_accepted.json ✓
5. Apply guardrails ✓
6. Generate ESLint rules → .eslintrc.adrs.json ✓
   (No restrictions in this ADR, just baseline setup)
7. Generate Ruff rules (skip - no Python policies)
8. Update index → docs/adr/adr-index.json ✓
9. Quick compliance scan ✓

Returns:
{
  "adr_id": "ADR-0001",
  "status": "accepted",
  "policies_activated": [],
  "configurations_updated": [
    "docs/adr/ADR-0001-use-react-for-frontend.md",
    ".adr-kit/constraints_accepted.json",
    "docs/adr/adr-index.json"
  ],
  "warnings": [],
  "guidance": "✅ ADR-0001 fully approved and operational. 0 policy rules applied (no restrictions defined in this ADR)."
}

═══════════════════════════════════════════════════════════════
AGENT → USER (Completion)
═══════════════════════════════════════════════════════════════

Agent: "✅ ADR-0001 is now approved! Your decision to use React is officially documented.

**Files updated**:
- docs/adr/ADR-0001-use-react-for-frontend.md (status: accepted)
- .adr-kit/constraints_accepted.json
- docs/adr/adr-index.json

Your architectural decision is now part of the project's record."

═══════════════════════════════════════════════════════════════
SCENARIO COMPLETE
═══════════════════════════════════════════════════════════════

Total MCP calls: 3 (preflight → create → approve)
User interactions: 2 (initial request + EXPLICIT approval confirmation)
Files created: 3
Time: ~1-2 seconds total

Critical: Agent did NOT auto-approve - waited for user confirmation
```

### Key Takeaways

1. **Preflight first**: Even for a simple request, the agent checked if an ADR was needed
2. **Create writes file**: The ADR file is created with status "proposed" immediately
3. **Approval required**: Agent showed you the ADR and WAITED for your approval
4. **3 files updated**: Approval updates the ADR, contract, and index
5. **Loop-backs**: Initial request triggered 3 workflow calls

---

## Scenario 2: Brownfield Project - Analyze & Document

**User Goal**: Analyze an existing project and create ADRs for undocumented decisions

### Complete Interaction

```
═══════════════════════════════════════════════════════════════
USER (Start)
═══════════════════════════════════════════════════════════════

You: "Analyze my existing project and help me document the architectural decisions"

═══════════════════════════════════════════════════════════════
AGENT (Reasons & Acts)
═══════════════════════════════════════════════════════════════

Agent reasons: "User has existing project - brownfield analysis needed"

───────────────────────────────────────────────────────────────
STEP 1: Analyze Project
───────────────────────────────────────────────────────────────

Agent calls: adr_analyze_project({
  project_path: ".",
  adr_dir: "docs/adr"
})

Workflow executes:
├─ Scan project files
│   ├─ Found: package.json, tsconfig.json, docker-compose.yml
│   ├─ Found: src/components/*.tsx, src/server.ts, src/auth/
│   └─ File count: 247 .ts files, 89 .tsx files, 15 .py files
├─ Detect technologies (pattern matching + confidence scoring):
│   ├─ React (confidence: 0.9) - package.json + src/components/
│   ├─ TypeScript (confidence: 0.9) - tsconfig.json + .ts files
│   ├─ Express (confidence: 0.8) - package.json + src/server.ts
│   ├─ PostgreSQL (confidence: 0.9) - docker-compose.yml + pg imports
│   ├─ Docker (confidence: 0.8) - Dockerfile + docker-compose.yml
│   └─ Auth0 (confidence: 0.7) - @auth0 package + src/auth/
├─ Check existing ADRs: 0 found
└─ Generate analysis promptlet (for agent's LLM to follow)

Returns:
{
  "detected_technologies": ["React", "TypeScript", "Express", "PostgreSQL", "Docker", "Auth0"],
  "confidence_scores": {
    "React": 0.9,
    "TypeScript": 0.9,
    "Express": 0.8,
    "PostgreSQL": 0.9,
    "Docker": 0.8,
    "Auth0": 0.7
  },
  "existing_adr_count": 0,
  "analysis_prompt": "Please analyze this project for architectural decisions...\n\n**Project Context:**\n- Detected technologies: React (90% confidence), TypeScript (90% confidence), Express (80% confidence), PostgreSQL (90% confidence), Docker (80% confidence), Auth0 (70% confidence)\n- No existing ADRs found\n- This appears to be a full-stack web application\n\n**Analysis Focus:**\n1. Identify ALL significant architectural decisions made in this project\n2. Focus on framework choices, data architecture, API design, authentication strategy, deployment approach\n3. For each decision, consider:\n   - Context: Why was this technology needed?\n   - Decision: What was chosen and how is it used?\n   - Consequences: What are the trade-offs?\n\n**Instructions:**\n1. Examine project structure:\n   - src/components/ for React component architecture\n   - src/server.ts for Express API design\n   - docker-compose.yml for PostgreSQL setup\n   - src/auth/ for Auth0 integration\n2. Check configuration files (package.json, tsconfig.json, Dockerfile)\n3. Look for patterns that indicate architectural choices\n4. For each architectural decision you identify:\n   - Draft context (the situation that prompted this choice)\n   - Note the decision (what was chosen and how it's used)\n   - List consequences (positive and negative trade-offs)\n\n**Suggested Focus Areas:**\n- Frontend: Why React? Component architecture patterns?\n- Type Safety: Why TypeScript? How strict is it configured?\n- Backend: Why Express? RESTful API design?\n- Database: Why PostgreSQL? Schema design approach?\n- Authentication: Why Auth0? JWT strategy?\n- Deployment: Why Docker? Container orchestration approach?",
  "suggested_focus": ["frontend_architecture", "backend_api", "data_architecture", "authentication", "deployment"],
  "next_steps": [
    "Follow the analysis prompt to analyze the entire project architecture",
    "Identify all significant architectural decisions",
    "Present findings to user before creating ADRs"
  ]
}

Agent's LLM reads analysis_prompt (the detailed promptlet)

───────────────────────────────────────────────────────────────
AGENT EXAMINES CODEBASE (LLM-powered analysis following promptlet)
───────────────────────────────────────────────────────────────

Agent's LLM examines files based on promptlet instructions:
- package.json → React, TypeScript, Express, Auth0 dependencies
- src/components/ → React functional components with hooks
- src/server.ts → Express REST API with JSON responses
- docker-compose.yml → PostgreSQL 14 container
- src/auth/ → Auth0 integration with JWT validation middleware

Agent's LLM identifies 5 major architectural decisions:
1. React for frontend UI (functional components, hooks pattern)
2. TypeScript for type safety (strict mode enabled)
3. Express for REST API backend
4. PostgreSQL for relational data storage
5. Auth0 for authentication (OAuth2 + JWT)

═══════════════════════════════════════════════════════════════
AGENT → USER (Shows findings, ASKS permission)
═══════════════════════════════════════════════════════════════

Agent: "I've analyzed your project and found 5 major architectural decisions:

1. **React for Frontend**: Functional components with hooks pattern
   - Detected in: src/components/ (89 .tsx files)

2. **TypeScript for Type Safety**: Strict mode enabled
   - Detected in: tsconfig.json + 247 .ts files

3. **Express for REST API**: RESTful backend with JSON responses
   - Detected in: src/server.ts + Express middleware

4. **PostgreSQL for Data Storage**: Relational database (v14)
   - Detected in: docker-compose.yml + PostgreSQL imports

5. **Auth0 for Authentication**: OAuth2 + JWT token strategy
   - Detected in: src/auth/ + @auth0 packages

**Would you like me to create ADRs for these decisions?**"

[AGENT WAITS - ASKS BEFORE CREATING]

═══════════════════════════════════════════════════════════════
USER (Gives permission)
═══════════════════════════════════════════════════════════════

You: "Yes, create ADRs for all of them"  ← USER PERMISSION

═══════════════════════════════════════════════════════════════
AGENT (Creates ADRs AFTER user permission)
═══════════════════════════════════════════════════════════════

───────────────────────────────────────────────────────────────
STEP 2: Create 5 ADRs [5 LOOP BACKS]
───────────────────────────────────────────────────────────────

Agent calls: adr_create({
  title: "Use React for Frontend UI",
  context: "Need component-based UI framework for interactive web application with strong TypeScript support and large ecosystem",
  decision: "Use React with functional components and hooks for all frontend development",
  consequences: "Positive:\n- Reusable component architecture\n- Large ecosystem with extensive libraries\n- Strong TypeScript support\n- Virtual DOM performance\n\nNegative:\n- Requires build tooling\n- Learning curve for hooks",
  tags: ["frontend", "react", "ui"]
})
→ Returns: ADR-0001

Agent calls: adr_create({
  title: "Use TypeScript for Type Safety",
  context: "JavaScript's dynamic typing leads to runtime errors in production. Need compile-time type checking",
  decision: "Use TypeScript in strict mode for all frontend and backend code",
  consequences: "Positive:\n- Compile-time error detection\n- Better IDE autocomplete and refactoring\n- Self-documenting code through types\n\nNegative:\n- Build step required\n- Learning curve for advanced types",
  tags: ["typescript", "tooling", "type-safety"]
})
→ Returns: ADR-0002

Agent calls: adr_create({
  title: "Use Express for REST API",
  context: "Need lightweight, flexible Node.js framework for building RESTful API with JSON responses",
  decision: "Use Express for all backend API endpoints with RESTful design",
  consequences: "Positive:\n- Minimal and unopinionated\n- Good ecosystem of middleware\n- Familiar to Node.js developers\n\nNegative:\n- Manual structure needed\n- No built-in validation",
  tags: ["backend", "api", "express"]
})
→ Returns: ADR-0003

Agent calls: adr_create({
  title: "Use PostgreSQL for Data Storage",
  context: "Need reliable relational database for structured data with ACID guarantees and complex queries",
  decision: "Use PostgreSQL as primary database for all persistent data",
  consequences: "Positive:\n- ACID compliance\n- Rich query capabilities\n- JSON support for flexible data\n- Excellent performance\n\nNegative:\n- Requires schema management\n- More setup than document DBs",
  tags: ["database", "postgresql", "data"]
})
→ Returns: ADR-0004

Agent calls: adr_create({
  title: "Use Auth0 for Authentication",
  context: "Authentication is security-critical and complex. Building custom auth is risky and time-consuming",
  decision: "Use Auth0 for user authentication and authorization with JWT tokens",
  consequences: "Positive:\n- Security expertise from Auth0 team\n- OAuth2/SSO support out of the box\n- Automatic security updates\n- JWT token management\n\nNegative:\n- Third-party dependency\n- Ongoing cost\n- Vendor lock-in risk",
  tags: ["security", "authentication", "auth0"],
  policy: {
    imports: {
      prefer: ["@auth0/auth0-react", "@auth0/auth0-spa-js"],
      disallow: ["passport", "jsonwebtoken", "bcrypt"]
    }
  }
})
→ Returns: ADR-0005 (includes policy!)

All created with status: "proposed"

═══════════════════════════════════════════════════════════════
AGENT → USER (Shows ADRs, WAITS for approval)
═══════════════════════════════════════════════════════════════

Agent: "I've created 5 ADRs documenting your architectural decisions:

**ADR-0001**: Use React for Frontend UI
**ADR-0002**: Use TypeScript for Type Safety
**ADR-0003**: Use Express for REST API
**ADR-0004**: Use PostgreSQL for Data Storage
**ADR-0005**: Use Auth0 for Authentication (includes policy: disallow passport/jsonwebtoken/bcrypt)

All are in 'proposed' status. **Would you like to review and approve them?**"

[AGENT WAITS - DOES NOT AUTO-APPROVE]

═══════════════════════════════════════════════════════════════
USER (Reviews & EXPLICITLY approves)
═══════════════════════════════════════════════════════════════

You: "Looks good! Approve all of them"  ← REQUIRED USER CONFIRMATION

═══════════════════════════════════════════════════════════════
AGENT (Approves ONLY after user confirmation)
═══════════════════════════════════════════════════════════════

───────────────────────────────────────────────────────────────
STEP 3: Approve all ADRs [5 LOOP BACKS - User Initiated]
───────────────────────────────────────────────────────────────

Agent calls: adr_approve({adr_id: "ADR-0001"}) → ✓
Agent calls: adr_approve({adr_id: "ADR-0002"}) → ✓
Agent calls: adr_approve({adr_id: "ADR-0003"}) → ✓
Agent calls: adr_approve({adr_id: "ADR-0004"}) → ✓
Agent calls: adr_approve({adr_id: "ADR-0005"}) → ✓ (generates ESLint rules!)

Each approval runs the 9-step pipeline:
- Updates ADR status to "accepted"
- Rebuilds constraints contract
- Generates enforcement rules
- Updates indexes

ADR-0005 specifically:
- Generates .eslintrc.adrs.json with:
  - no-restricted-imports: "passport"
  - no-restricted-imports: "jsonwebtoken"
  - no-restricted-imports: "bcrypt"

═══════════════════════════════════════════════════════════════
AGENT → USER (Completion)
═══════════════════════════════════════════════════════════════

Agent: "✅ All 5 ADRs are now approved and active!

**Files created/updated**:
- docs/adr/ADR-0001-use-react.md through ADR-0005-use-auth0.md (all status: accepted)
- .eslintrc.adrs.json (Auth0 policy enforcement)
- .adr-kit/constraints_accepted.json
- docs/adr/adr-index.json

**Policy enforcement is now active**:
- ESLint will block imports of 'passport', 'jsonwebtoken', and 'bcrypt'
- Enforces use of '@auth0/auth0-react' for authentication

Your architectural decisions are now documented and enforceable in your editor and CI/CD!"

═══════════════════════════════════════════════════════════════
DEMONSTRATION: Policy Enforcement
═══════════════════════════════════════════════════════════════

[Later, a developer writes this code:]

```javascript
import passport from 'passport';  // ❌ ESLint error!
```

ESLint error:
```
'passport' import is restricted from being used.
Use @auth0/auth0-react instead (enforced by ADR-0005)
```

═══════════════════════════════════════════════════════════════
SCENARIO COMPLETE
═══════════════════════════════════════════════════════════════

Total MCP calls: 11 (1 analyze + 5 creates + 5 approves)
User interactions: 3 (initial request + permission to create + EXPLICIT approval)
Files created: 8 (5 ADRs + 3 config files)
Policies enforced: 3 (no passport, no jsonwebtoken, no bcrypt)
Time: ~5-10 seconds total

Critical: Agent did NOT auto-create OR auto-approve - waited for user confirmation at each step
```

### Key Takeaways

1. **Analysis generates promptlet**: The workflow doesn't analyze code - it generates instructions for the agent's LLM
2. **LLM does the reasoning**: Agent's LLM examined the actual files and identified decisions
3. **Permission before creating**: Agent asked before creating 5 ADRs
4. **Approval required**: Agent waited for explicit approval before activating policies
5. **Policy enforcement**: ADR-0005's policy immediately started blocking disallowed imports
6. **11 workflow calls**: One request triggered analyze → 5 creates → 5 approves

---

## Scenario 3: Checking Before Implementation

**User Goal**: Check if a proposed technology choice is allowed before implementing

### Complete Interaction

```
═══════════════════════════════════════════════════════════════
USER (Start)
═══════════════════════════════════════════════════════════════

You: "I want to use Axios for HTTP requests in my React app"

═══════════════════════════════════════════════════════════════
AGENT (Reasons & Acts)
═══════════════════════════════════════════════════════════════

Agent reasons: "User proposing technical choice - should check if allowed"
Agent reasons: "Preflight check will tell me if this is okay"

───────────────────────────────────────────────────────────────
STEP 1: Preflight Check
───────────────────────────────────────────────────────────────

Agent calls: adr_preflight({
  choice: "axios",
  context: "HTTP client for API requests in React application"
})

Workflow executes:
├─ Load constraints contract
│   └─ Loads all approved ADRs and their policies
├─ Categorize choice: "axios" → "frontend/http-client"
├─ Check policies:
│   └─ Finds ADR-0005: policy.imports.disallow includes "axios"
├─ Decision: BLOCKED (conflicts with existing policy)
└─ Generate guidance promptlet

Returns:
{
  "decision": "BLOCKED",
  "reasoning": "Conflicts with ADR-0005: Use Auth0 for Authentication. Auth0's SDK handles HTTP requests; axios is explicitly disallowed to prevent bypassing Auth0's security.",
  "conflicting_adrs": ["ADR-0005"],
  "guidance": "🚫 Cannot use 'axios'. Conflicts with ADR-0005.",
  "next_steps": [
    "Review ADR-0005 to understand why axios is disallowed",
    "Use Auth0's built-in HTTP client instead",
    "OR if axios is truly required, use adr_supersede() to change the architectural decision"
  ]
}

═══════════════════════════════════════════════════════════════
AGENT → USER (Explains block, offers options)
═══════════════════════════════════════════════════════════════

Agent: "🚫 I can't proceed with Axios. It conflicts with **ADR-0005: Use Auth0 for Authentication**.

**Why it's blocked**:
ADR-0005's policy explicitly disallows `axios` because Auth0's SDK provides its own HTTP client for secure API communication. Using axios could bypass Auth0's security layer.

**Your options**:
1. **Use Auth0's built-in client** (recommended per ADR-0005)
   - Auth0 SDK handles authenticated HTTP requests securely
   - Automatically includes JWT tokens in requests

2. **Change the architectural decision** (if axios is truly needed)
   - We would need to supersede ADR-0005 with a new decision
   - This requires documenting why axios is necessary despite the security trade-off

What would you like to do?"

[AGENT WAITS for user decision - does NOT auto-supersede]

═══════════════════════════════════════════════════════════════
USER (Decides - Scenario A: Accepts recommendation)
═══════════════════════════════════════════════════════════════

You: "OK, I'll use Auth0's client instead. How do I do that?"

Agent: "Great! Here's how to use Auth0's HTTP client:

```typescript
import { useAuth0 } from '@auth0/auth0-react';

function MyComponent() {
  const { getAccessTokenSilently } = useAuth0();

  const fetchData = async () => {
    const token = await getAccessTokenSilently();
    const response = await fetch('/api/data', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    return response.json();
  };
}
```

This approach:
- Automatically handles JWT token refresh
- Ensures all requests are authenticated
- Follows the pattern established in ADR-0005"

═══════════════════════════════════════════════════════════════
SCENARIO A COMPLETE
═══════════════════════════════════════════════════════════════

Total MCP calls: 1 (preflight only - user accepted recommendation)
User interactions: 2 (initial request + decision to use recommended approach)
Files changed: 0
Time: <1 second

Critical: Preflight prevented non-compliant choice before any code was written
```

**Alternative path**: User decides they need Axios

```
═══════════════════════════════════════════════════════════════
USER (Decides - Scenario B: Needs the blocked technology)
═══════════════════════════════════════════════════════════════

You: "Actually, we're integrating with a third-party API that doesn't use Auth0. We need Axios for those calls. Can you supersede ADR-0005?"

Agent: "I understand - you need Axios for non-Auth0 API integrations. Let me help create a new ADR that supersedes ADR-0005.

We'll need to document:
- Why axios is needed (third-party API integration)
- How it will be used (separate from Auth0-authenticated calls)
- Security considerations (how to keep it secure)

Should I create a new ADR titled 'Use Axios for Third-Party API Integration'?"

You: "Yes, create it"

───────────────────────────────────────────────────────────────
STEP 2: Supersede ADR [LOOP BACK]
───────────────────────────────────────────────────────────────

Agent calls: adr_supersede({
  old_adr_id: "ADR-0005",
  new_title: "Use Auth0 for Authentication and Axios for Third-Party APIs",
  new_context: "Application needs both Auth0 for user authentication AND Axios for third-party API integrations that don't support Auth0",
  new_decision: "Use Auth0's SDK for all user-authenticated requests. Use Axios for third-party API calls outside the Auth0 ecosystem.",
  new_consequences: "Positive:\n- Can integrate with non-Auth0 APIs\n- Axios provides better error handling for third-party calls\n\nNegative:\n- Two HTTP clients to maintain\n- Risk of confusion about which to use when\n- Axios calls must manually handle security",
  supersede_reason: "Need to support third-party API integrations that don't use Auth0",
  auto_approve: false,
  policy: {
    imports: {
      prefer: ["@auth0/auth0-react", "axios"],
      disallow: ["passport", "jsonwebtoken", "bcrypt"]
    }
  }
})

Workflow executes:
├─ Validate ADR-0005 exists ✓
├─ Create new ADR (calls CreationWorkflow)
│   └─ Creates ADR-0006
├─ Update ADR-0005:
│   ├─ status: accepted → superseded
│   ├─ superseded_by: ["ADR-0006"]
│   └─ Add supersede_date, supersede_reason
├─ Update ADR-0006:
│   └─ supersedes: ["ADR-0005"]
└─ Generate guidance (auto_approve=false)

Returns:
{
  "old_adr_id": "ADR-0005",
  "new_adr_id": "ADR-0006",
  "old_status": "superseded",
  "new_status": "proposed",
  "guidance": "📋 Superseding complete! ADR-0006 created but requires approval."
}

Agent: "I've created ADR-0006 which supersedes ADR-0005. Here's what changed:

**ADR-0006** now allows BOTH:
- Auth0's SDK for user authentication
- Axios for third-party API integration

**ADR-0005** is now marked as 'superseded'

The new policy will:
- ✅ Allow axios imports
- ✅ Still prefer @auth0/auth0-react
- 🚫 Still block passport, jsonwebtoken, bcrypt

Should I approve ADR-0006?"

You: "Yes, approve it"

───────────────────────────────────────────────────────────────
STEP 3: Approve new ADR [LOOP BACK]
───────────────────────────────────────────────────────────────

Agent calls: adr_approve({adr_id: "ADR-0006"})

Workflow updates:
- ADR-0006 status → accepted
- Rebuilds constraints (ADR-0005 out, ADR-0006 in)
- Updates .eslintrc.adrs.json (axios now allowed!)

Agent: "✅ ADR-0006 approved! You can now use Axios for third-party API integrations.

The policy has been updated - ESLint will no longer block axios imports."

═══════════════════════════════════════════════════════════════
SCENARIO B COMPLETE
═══════════════════════════════════════════════════════════════

Total MCP calls: 3 (preflight → supersede → approve)
User interactions: 4 (initial request + decision + create ADR + approve)
Files changed: 5 (ADR-0005 updated, ADR-0006 created, 3 config files)
Time: ~2-3 seconds

Critical: Agent explained why blocked, offered options, waited for user decision at each step
```

### Key Takeaways

1. **Preflight prevents mistakes**: Caught the policy violation BEFORE code was written
2. **Agent explains WHY**: Not just "blocked" but the architectural reasoning
3. **User decides**: Agent offers options, user chooses the path forward
4. **Supersede when needed**: When architectural decisions must change, supersede documents it
5. **Bidirectional relationships**: ADR-0005 now points to ADR-0006 (superseded_by), and vice versa

---

## Summary: Common Patterns Across Scenarios

### The User Approval Pattern

**Never auto-approved**:
- Creating ADRs in bulk (Scenario 2: agent asked permission)
- Approving ADRs (All scenarios: explicit "approve" confirmation required)
- Superseding ADRs (Scenario 3B: explicit approval required)

**Can be automatic**:
- Running analysis (read-only)
- Running preflight checks (read-only)
- Creating a single ADR when user directly requests it (Scenario 1)

### The Loop-Back Pattern

**Single workflow call** (no loop):
- Preflight returns ALLOWED → user proceeds (Scenario 3A)
- Approve ADR → policies active, done (terminal)

**Multiple workflow calls** (loop-backs):
- Analyze → Create × N → Approve × N (Scenario 2: 11 calls total)
- Preflight REQUIRES_ADR → Create → Approve (Scenario 1: 3 calls total)
- Preflight BLOCKED → Supersede → Approve (Scenario 3B: 3 calls total)

### The Promptlet Pattern

**Heavy LLM coordination workflows** (generate detailed instructions):
- Analyze: Generates multi-paragraph analysis instructions
- Planning: Generates guidance promptlets and compliance checklists

**Light LLM coordination workflows** (status messages):
- Approve: Simple success/failure messages
- Supersede: Status updates

**Medium LLM coordination workflows** (actionable guidance):
- Preflight: Decision + reasoning + next steps
- Create: Next steps with conflict information

---

With these complete scenarios understood, you're ready to dive into each workflow individually. The next section provides deep dives into how each workflow works internally.

---

# Individual Workflow Deep Dives

Now that you've seen workflows in action through complete scenarios, this section explains each workflow's internal mechanics, inputs/outputs, and key behaviors.

## Workflow 1: Analyze Project

**Purpose**: Detect technologies in an existing codebase and generate analysis instructions for AI agents.

**When to Use**:
- Brownfield projects (existing codebases without ADRs)
- Initial ADR adoption
- Discovering undocumented architectural decisions

### What It Does (Automation)

1. **Scans project structure** (100-500ms):
   - Looks for config files: `package.json`, `requirements.txt`, `tsconfig.json`, `Dockerfile`, `docker-compose.yml`
   - Counts file types: `.js`, `.ts`, `.tsx`, `.py`, `.java`, etc.
   - Identifies frameworks from package dependencies

2. **Detects technologies** using pattern matching:
   - 20+ technology patterns (React, Express, PostgreSQL, Auth0, etc.)
   - Confidence scoring (0.0-1.0) based on:
     - Config file presence: +0.3
     - File count: +0.1 per 10 files (up to +0.5)
     - Package.json dependency: +0.4
   - Threshold: 0.3 minimum to report a technology

3. **Checks for existing ADRs**:
   - Scans `docs/adr/` directory
   - Counts existing ADR files
   - Identifies which decisions are already documented

### What It Returns (LLM Coordination)

Generates a **detailed analysis promptlet** for the agent's LLM to follow:

```markdown
Please analyze this project for architectural decisions...

**Project Context:**
- Detected technologies: React (90% confidence), Express (80% confidence)
- File structure suggests full-stack web application
- No existing ADRs found

**Analysis Focus:**
1. Identify ALL significant architectural decisions
2. Focus on framework choices, data architecture, API design
3. For each decision, consider:
   - Context: Why was this technology needed?
   - Decision: What was chosen and how is it used?
   - Consequences: What are the trade-offs?

**Instructions:**
1. Examine src/components/ for React patterns
2. Check src/server.ts for Express API design
3. Review configuration files
...
```

**Key Insight**: The workflow doesn't analyze code—it scans for patterns and generates instructions that the agent's LLM follows to do the actual analysis.

### Input

```python
{
  "project_path": ".",  # Path to project root
  "adr_dir": "docs/adr",  # Where ADRs should live
  "focus_areas": ["frontend", "backend"]  # Optional: specific areas to analyze
}
```

### Output

```python
{
  "detected_technologies": ["React", "Express", "PostgreSQL"],
  "confidence_scores": {"React": 0.9, "Express": 0.8, ...},
  "existing_adr_count": 0,
  "analysis_prompt": "Please analyze this project...",  # PROMPTLET
  "suggested_focus": ["frontend_architecture", "api_design"],
  "next_steps": [  # PROMPTLET
    "Follow the analysis prompt to analyze the project",
    "Identify all significant architectural decisions",
    "Present findings to user before creating ADRs"
  ]
}
```

---

## Workflow 2: Preflight Check

**Purpose**: Check if a proposed technical choice is allowed, requires documentation, or is blocked.

**When to Use**:
- Before implementing any technical choice
- Before adding new dependencies
- As a "gate" before proceeding with code changes

### What It Does (Automation)

1. **Loads constraints contract** (50-100ms):
   - Reads all approved ADRs
   - Merges their policy blocks
   - Builds enforcement rules

2. **Categorizes the choice**:
   - Normalizes technology name (postgres/postgresql/pg → "postgresql")
   - Determines category: database/frontend/backend/architecture/tool

3. **Checks policies**:
   - Searches for conflicts with existing policies
   - Looks for related ADRs
   - Determines significance (framework/database/auth always significant)

4. **Makes decision**:
   - **ALLOWED**: Choice aligns with existing policies or is pre-approved
   - **REQUIRES_ADR**: Significant choice without existing documentation
   - **BLOCKED**: Conflicts with an existing policy

### What It Returns (LLM Coordination)

**Decision + reasoning + guidance**:

```python
# ALLOWED example
{
  "decision": "ALLOWED",
  "reasoning": "Aligns with ADR-0005: Use PostgreSQL for data storage",
  "guidance": "✅ You can proceed with 'postgresql'",
  "next_steps": ["Proceed with implementation"]
}

# REQUIRES_ADR example
{
  "decision": "REQUIRES_ADR",
  "reasoning": "Framework choice is architecturally significant",
  "guidance": "📝 'React' requires ADR before proceeding",
  "next_steps": ["Create ADR proposal documenting this decision"]
}

# BLOCKED example
{
  "decision": "BLOCKED",
  "reasoning": "Conflicts with ADR-0005: Use Auth0 (disallows passport)",
  "conflicting_adrs": ["ADR-0005"],
  "guidance": "🚫 Cannot use 'passport'",
  "next_steps": [
    "Review ADR-0005",
    "Use Auth0 instead",
    "OR use adr_supersede() to change the decision"
  ]
}
```

**Key Insight**: Preflight is a "traffic light" - green (ALLOWED), yellow (REQUIRES_ADR), red (BLOCKED). It prevents policy violations BEFORE code is written.

---

## Workflow 3: Create ADR

**Purpose**: Create a new ADR proposal file with conflict detection.

**When to Use**:
- Documenting a new architectural decision
- After preflight returns REQUIRES_ADR
- During brownfield analysis when decisions are identified

### What It Does (Automation)

1. **Generates ADR ID** (sequential):
   - Scans existing ADRs: `ADR-0001`, `ADR-0002`, etc.
   - Finds highest number
   - Generates next ID: `ADR-0003`

2. **Validates input**:
   - Title: min 3 characters
   - Context: min 10 characters
   - Decision: min 5 characters
   - Consequences: min 5 characters

3. **Finds related ADRs** (keyword matching):
   - Extracts tech terms from title/context/decision
   - Searches existing ADRs for matching terms
   - Calculates relevance score (matches/total_terms)
   - Returns top 10 most relevant

4. **Detects conflicts**:
   - **Policy conflicts**: Checks if proposed policy contradicts existing policies
   - **Decision conflicts**: Looks for opposing terms (use/avoid, adopt/reject)

5. **Writes ADR file** (MADR format):
   - Filename: `ADR-0003-title-slug.md`
   - Status: **"proposed"** (NOT approved yet!)
   - YAML frontmatter + Markdown sections

### What It Returns (LLM Coordination)

**File path + conflict info + next steps**:

```python
{
  "adr_id": "ADR-0003",
  "file_path": "docs/adr/ADR-0003-use-mongodb.md",
  "status": "proposed",
  "conflicts_detected": ["ADR-0002"],  # Conflicts with PostgreSQL decision
  "related_adrs": ["ADR-0002", "ADR-0005"],
  "validation_warnings": [],
  "review_required": true,  # Conflicts or significant decision
  "next_steps": [  # PROMPTLET
    "Review conflicts with ADR-0002",
    "Revise proposal OR use adr_supersede()"
  ]
}
```

**Key Insight**: Create writes a file but doesn't activate policies. The ADR stays in "proposed" status until approved. This two-step process (create → approve) ensures human review.

### 🚨 User Approval Required

⚠️ **Creating a single ADR**: Usually automatic when user directly requests it
✅ **Creating multiple ADRs**: Agent should ask permission first
✅ **Approving ADRs**: ALWAYS requires explicit user confirmation

---

## Workflow 4: Approve ADR (The Big Automation Pipeline)

**Purpose**: Activate an ADR and trigger comprehensive policy enforcement.

**When to Use**:
- After creating and reviewing an ADR
- When ready to make policies enforceable
- **ONLY after explicit user approval**

### What It Does (Automation) - 9 Steps

This is the **most complex workflow** with the **heaviest automation**:

1. **Load & Validate ADR** (50ms):
   - Find ADR file by ID
   - Check status (must be "proposed", not already "accepted" or "superseded")
   - Run validation checks

2. **Content Integrity Check** (10ms):
   - Calculate SHA-256 hash of ADR content
   - Store for audit trail
   - Can be skipped with `digest_check=false`

3. **Update ADR Status** (20ms):
   - Regex replace: `status: proposed` → `status: accepted`
   - Add `approval_date` metadata
   - Add `approval_notes` if provided
   - Write file back to disk

4. **Rebuild Constraints Contract** (50ms):
   - Use `ConstraintsContractBuilder`
   - Merge all approved ADR policies
   - Write `.adr-kit/constraints_accepted.json`

5. **Apply Guardrails** (100ms):
   - Initialize `GuardrailManager`
   - Prepare for config updates

6. **Generate ESLint Rules** (20ms):
   - IF ADR has JavaScript/TypeScript policies
   - Write `.eslintrc.adrs.json`
   - Rules: `no-restricted-imports` for disallowed packages

7. **Generate Ruff Rules** (20ms):
   - IF ADR has Python policies
   - Update `pyproject.toml` `[tool.ruff]` section
   - Rules: `flake8-banned-api` for disallowed imports

8. **Update Indexes** (30ms):
   - Generate `adr-index.json` with all ADR metadata
   - Includes relationships (supersedes/superseded_by)
   - Write to `docs/adr/adr-index.json`

9. **Quick Compliance Scan** (50ms):
   - Scan for violations of new policies
   - Limits to files < 1MB
   - Returns first 10 violations (non-blocking)

**Total time**: 500-1000ms

### What It Returns (LLM Coordination)

**Success report + warnings**:

```python
{
  "adr_id": "ADR-0005",
  "status": "accepted",
  "content_digest": "a3f5...",
  "policies_activated": [
    "no-restricted-imports: passport",
    "no-restricted-imports: jsonwebtoken"
  ],
  "configurations_updated": [
    ".eslintrc.adrs.json",
    ".adr-kit/constraints_accepted.json",
    "docs/adr/adr-index.json"
  ],
  "warnings": [],  # Or list of automation failures
  "next_steps": [  # PROMPTLET
    "Policies are now active",
    "Commit the updated configuration files",
    "ESLint will now enforce these restrictions"
  ]
}
```

**Key Insight**: Approval is where ALL the magic happens. One call triggers 9 automation steps that write 3-5 files and activate policy enforcement. This is why user approval is ALWAYS required.

### 🚨 User Approval ALWAYS Required

✅ **CRITICAL**: Approval NEVER happens automatically
✅ **Why**: Activates policy enforcement - requires human oversight
✅ **Agent behavior**: Will ALWAYS wait for explicit "approve" confirmation

---

## Workflow 5: Supersede ADR

**Purpose**: Replace an existing ADR with a new decision while maintaining relationship history.

**When to Use**:
- Architectural decision has fundamentally changed
- Technology choice needs to be replaced
- Policy needs to be updated

### What It Does (Automation)

1. **Validates old ADR exists**:
   - Must exist and not already be superseded

2. **Creates new ADR** (calls CreationWorkflow):
   - Runs full creation workflow internally
   - Creates `ADR-0007` with new decision

3. **Updates old ADR**:
   - Changes status: `accepted` → `superseded`
   - Adds: `superseded_by: ["ADR-0007"]`
   - Adds metadata: `supersede_date`, `supersede_reason`

4. **Updates new ADR**:
   - Adds: `supersedes: ["ADR-0006"]`
   - Creates bidirectional relationship

5. **Updates related ADRs**:
   - Finds ADRs that reference the old ADR
   - Updates their relationship pointers

6. **Optionally approves** (if `auto_approve=true`):
   - Calls ApprovalWorkflow internally
   - Skips this step if `auto_approve=false` (default)

### What It Returns (LLM Coordination)

```python
{
  "old_adr_id": "ADR-0006",
  "new_adr_id": "ADR-0007",
  "old_status": "superseded",
  "new_status": "proposed",  # or "accepted" if auto_approve=true
  "relationships_updated": ["ADR-0003", "ADR-0004"],
  "automation_triggered": false,  # if auto_approve=false
  "next_steps": [  # PROMPTLET
    "Review ADR-0007",
    "Use adr_approve('ADR-0007') to activate"
  ]
}
```

**Key Insight**: Supersede is actually TWO workflows in one - it calls CreationWorkflow + optionally ApprovalWorkflow. With `auto_approve=true`, one call does everything.

### 🚨 User Approval Required

✅ **Always** for the approval step (if auto_approve=false)
⚠️ **Recommended** before creating the new ADR

---

## Workflow 6: Planning Context

**Purpose**: Provide architectural context and guidance for a specific implementation task.

**When to Use**:
- Before implementing a new feature
- When starting work on a specific task
- To understand relevant constraints

### What It Does (Automation)

1. **Analyzes task description** (NLP-lite):
   - Extracts technologies (regex patterns)
   - Extracts domains (frontend/backend/database/security)
   - Extracts intents (implement/refactor/fix/test)
   - Extracts architectural concepts

2. **Loads constraints contract**:
   - Reads all approved ADRs and policies

3. **Finds relevant ADRs**:
   - Calculates relevance scores (keyword matching)
   - Ranks by relevance
   - Returns top N (depends on priority: high=10, normal=6, low=3)

4. **Extracts applicable constraints**:
   - Filters policies relevant to task
   - Assigns enforcement level (required/recommended)

### What It Returns (LLM Coordination - HEAVY)

**Comprehensive architectural context**:

```python
{
  "relevant_adrs": [
    {
      "adr_id": "ADR-0005",
      "title": "Use Auth0 for authentication",
      "relevance_score": 0.95,
      "key_policies": ["Must use Auth0; Avoid: passport"],
      "decision_summary": "All authentication must use Auth0..."
    }
  ],
  "applicable_constraints": [
    {
      "adr_id": "ADR-0005",
      "policy_summary": "Must use Auth0; Avoid: passport, jsonwebtoken",
      "enforcement_level": "required"
    }
  ],
  "guidance_prompts": [  # PROMPTLETS
    "Before implementing, ensure approach aligns with existing decisions",
    "Pay special attention to ADR-0005: Use Auth0 for authentication",
    "This is a medium complexity task - validate each step"
  ],
  "technology_recommendations": {
    "recommended": ["@auth0/auth0-react"],
    "avoid": ["passport", "jsonwebtoken"],
    "required": []
  },
  "architecture_patterns": ["OAuth2 flow", "JWT refresh tokens"],
  "compliance_checklist": [  # PROMPTLETS
    "✓ Verify Auth0 is used (ADR-0005)",
    "✓ Check JWT validation is implemented",
    "✓ Ensure security considerations are addressed"
  ]
}
```

**Key Insight**: Planning is HEAVY on LLM coordination. It provides minimal automation (just loads data) but generates comprehensive guidance promptlets that the agent uses throughout implementation.

---

# Quick Reference

## When to Use Each Workflow

| Situation | Workflow | MCP Tool |
|-----------|----------|----------|
| Existing project, no ADRs | Analyze Project | `adr_analyze_project()` |
| Before using technology X | Preflight Check | `adr_preflight()` |
| Document a decision | Create ADR | `adr_create()` |
| Activate policies | Approve ADR | `adr_approve()` |
| Change a decision | Supersede ADR | `adr_supersede()` |
| Get implementation guidance | Planning Context | `adr_planning_context()` |

## Workflow Comparison

| Feature | Analyze | Preflight | Create | **Approve** | Supersede | Planning |
|---------|---------|-----------|--------|-------------|-----------|----------|
| **Automation Level** | Medium | Light | Heavy | **VERY HEAVY** | Heavy | Light |
| **LLM Coordination** | Heavy | Medium | Medium | Light | Light | Heavy |
| **Writes Files?** | No | No | Yes (1 ADR) | Yes (3-5 files) | Yes (2+ ADRs) | No |
| **Typical Duration** | 100-500ms | 50-100ms | 100-300ms | **500-1000ms** | 300-500ms | 100-200ms |
| **Triggers Loop?** | Always | Conditional | Usually | Never | Conditional | Never |
| **User Approval?** | No | No | Recommended | **ALWAYS YES** | YES | No |

## User Approval Requirements

| Action | Approval Required? | Why |
|--------|-------------------|-----|
| Analyze project | ❌ No | Read-only, just scanning |
| Preflight check | ❌ No | Read-only, just checking |
| **Create single ADR** | ⚠️ Usually no | User directly requested it |
| **Create multiple ADRs** | ✅ YES | Agent should ask permission |
| **Approve ADR** | ✅ **ALWAYS YES** | Activates policy enforcement |
| **Supersede ADR** | ✅ **YES** | Changes architectural decisions |
| Planning context | ❌ No | Read-only, reference material |

## Common Workflow Patterns

### Pattern 1: Standard Flow
```
User wants technology X
→ Preflight check (REQUIRES_ADR)
→ Create ADR (proposed)
→ User reviews
→ Approve ADR (REQUIRES user confirmation)
→ Policies active
```

### Pattern 2: Analysis Flow
```
Existing project
→ Analyze project (generates promptlet)
→ Agent's LLM examines code
→ Create × N ADRs (REQUIRES user permission for bulk)
→ User reviews all
→ Approve × N (REQUIRES user confirmation for each)
→ Policies active
```

### Pattern 3: Change Flow
```
Need to change decision
→ Supersede old ADR
→ Creates new ADR (proposed)
→ User reviews
→ Approve new ADR (REQUIRES user confirmation)
→ New policies active, old superseded
```

### Pattern 4: Guidance Flow
```
Starting implementation
→ Planning context (reference)
→ Agent uses guidance during work
→ No loop-back
```

## Performance Characteristics

**Automation overhead by workflow**:

| Workflow | Automation Time | LLM Coordination Time | Total |
|----------|----------------|----------------------|-------|
| Analyze | ~200ms | ~10ms (string formatting) | ~210ms |
| Preflight | ~60ms | ~5ms | ~65ms |
| Create | ~150ms | ~10ms | ~160ms |
| **Approve** | ~470ms | ~5ms | **~475ms** |
| Supersede | ~250ms | ~10ms | ~260ms |
| Planning | ~80ms | ~30ms (many promptlets) | ~110ms |

**Note**: These are workflow execution times. Total user-perceived time includes agent LLM reasoning time (varies).

## File Operations by Workflow

| Workflow | Files Read | Files Written | Config Files Updated |
|----------|------------|---------------|---------------------|
| Analyze | Config files, source structure | 0 | 0 |
| Preflight | ADRs, contracts | 0 | 0 |
| Create | ADRs (for conflict check) | 1 (ADR file) | 0 |
| **Approve** | ADR being approved | 1 (ADR status update) | **3-5 configs** |
| Supersede | Old+new ADRs | 2-3 (ADRs) | 0 (unless auto-approved) |
| Planning | ADRs, contracts | 0 | 0 |

**Approve workflow config files**:
- ADR file (status update)
- `.adr-kit/constraints_accepted.json`
- `.eslintrc.adrs.json` (if JS/TS policies)
- `pyproject.toml` (if Python policies)
- `docs/adr/adr-index.json`

---

## Summary: Key Takeaways

**Understanding Workflows**:

1. **Hybrid System**: Every workflow has automation (deterministic) + LLM coordination (promptlets)

2. **Two Outputs**: Data/files (what was done) + Promptlets (what agent should do next)

3. **Loop-Backs Are Normal**: One user request often triggers 3-11 workflow calls

4. **User Approval Gates**: Approvals and major changes ALWAYS require explicit confirmation

5. **Reasoning from LLM**: Workflows provide instructions, agent's LLM provides reasoning

6. **6 Workflows, 4 Patterns**: Learn the patterns, not just individual workflows

**Safety First**:

🚨 **Approval ALWAYS requires user confirmation** - Never automatic
⚠️ **Bulk operations ask permission** - Agent requests before creating many ADRs
✅ **Read-only operations automatic** - Analysis, preflight, planning run freely

**Performance**:

- Most workflows: < 200ms
- Approve workflow: 500-1000ms (9-step pipeline)
- Total user time: workflow time + agent LLM reasoning time

**Files**:

- Create: Writes 1 file
- Approve: Writes 3-5 files + activates policies
- Others: Read-only or minimal writes

---

## Further Reading

- **Getting Started**: See [GETTING_STARTED.md](./GETTING_STARTED.md) for step-by-step tutorials
- **AI Integration**: See [AI_INTEGRATION.md](./AI_INTEGRATION.md) for using ADR Kit with AI agents
- **Concepts**: See [CONCEPTS.md](./CONCEPTS.md) for core terminology and architecture
- **Source Code**: Explore [adr_kit/workflows/](../adr_kit/workflows/) for implementation details

---

*This documentation reflects ADR Kit v1.0+. Workflow behaviors and performance characteristics are based on Python 3.10+ with standard hardware.*

